<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式</title>
      <link href="/posts/a95e.html"/>
      <url>/posts/a95e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在写编译的时候发现在词法分析环节可以使用正则表达式来简化分析过程，故先对正则表达式进行学习。由于平时写的最多的还是JS，所以先从JS的正则入手，然后再分析Java和JS中正则的异同。</p></blockquote><h1 id="JS正则表达式"><a href="#JS正则表达式" class="headerlink" title="JS正则表达式"></a>JS正则表达式</h1><h2 id="模式和修饰符"><a href="#模式和修饰符" class="headerlink" title="模式和修饰符"></a>模式和修饰符</h2><p>在JavaScript中我们有两种创建正则表达式对象的语法：</p><p>较长一点的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regexp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;pattern&quot;</span>, <span class="string">&quot;flags&quot;</span>);</span><br></pre></td></tr></table></figure><p>较短一点的语法，使用斜线 <code>&quot;/&quot;</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regexp = <span class="regexp">/pattern/</span>; <span class="comment">// 没有修饰符</span></span><br><span class="line">regexp = <span class="regexp">/pattern/gmi</span>; <span class="comment">// 带有修饰符 g、m 和 i</span></span><br></pre></td></tr></table></figure><p>这两种语法之间的主要区别在于，使用斜线 <code>/.../</code> 的模式不允许插入表达式（如带有 <code>$&#123;...&#125;</code> 的字符串模板）。它是完全静态的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tag = <span class="title function_">prompt</span>(<span class="string">&quot;What tag do you want to find?&quot;</span>, <span class="string">&quot;h2&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`&lt;<span class="subst">$&#123;tag&#125;</span>&gt;`</span>);</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在 JavaScript 中，有 6 个修饰符：</p><ul><li><p><code>i</code></p><p>使用此修饰符后，搜索时不区分大小写。</p></li><li><p><code>g</code></p><p>使用此修饰符后，搜索时会寻找所有的匹配项 —— 没有它，则仅返回第一个匹配项。</p></li><li><p><code>m</code></p><p>多行模式。</p></li><li><p><code>s</code></p><p>启用 “dotall” 模式，允许点 <code>.</code> 匹配换行符 <code>\n</code>。</p></li><li><p><code>u</code></p><p>开启完整的 Unicode 支持。</p></li><li><p><code>y</code></p><p>粘滞模式，在文本中的确切位置搜索。</p></li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p><code>str.match(regexp)</code> 方法在字符串 <code>str</code> 中寻找 <code>regexp</code> 的所有匹配项。</p><p>如果有修饰符<code>g</code>，则返回一个由所有匹配项构成的数组；如果没有这样的修饰符，则会以<strong>数组形式</strong>返回第一个匹配项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;We will, we will rock you&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = str.<span class="title function_">match</span>(<span class="regexp">/we/i</span>); <span class="comment">// 没有修饰符 g</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( result[<span class="number">0</span>] );     <span class="comment">// We（第一个匹配项）</span></span><br><span class="line"><span class="title function_">alert</span>( result.<span class="property">length</span> ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>如果没有匹配组，则返回<code>null</code>。</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>str.replace(regexp, replacement)</code> 方法使用 <code>replacement</code> 替换在字符串 <code>str</code> 中找到的 <code>regexp</code> 的匹配项（如果带有修饰符 <code>g</code> 则替换所有匹配项，否则只替换第一个）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有修饰符 g</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;We will, we will&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/we/i</span>, <span class="string">&quot;I&quot;</span>) ); <span class="comment">// I will, we will</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有修饰符 g</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;We will, we will&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/we/ig</span>, <span class="string">&quot;I&quot;</span>) ); <span class="comment">// I will, I will</span></span><br></pre></td></tr></table></figure><p>对于第二个参数 <code>replacement</code> ，可以在其中使用特殊字符组合来对匹配项进行插入：</p><div class="table-container"><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">在替换字符串中的行为</th></tr></thead><tbody><tr><td style="text-align:left"><code>$&amp;</code></td><td style="text-align:left">插入整个匹配项</td></tr><tr><td style="text-align:left">$`</td><td style="text-align:left">插入字符串中匹配项之前的字符串部分</td></tr><tr><td style="text-align:left"><code>$&#39;</code></td><td style="text-align:left">插入字符串中匹配项之后的字符串部分</td></tr><tr><td style="text-align:left"><code>$n</code></td><td style="text-align:left">如果 <code>n</code> 是一个 1-2 位的数字，则插入第 n 个分组的内容</td></tr><tr><td style="text-align:left"><code>$&lt;name&gt;</code></td><td style="text-align:left">插入带有给定 <code>name</code> 的括号内的内容</td></tr><tr><td style="text-align:left">$$$$</td><td style="text-align:left">插入字符 <code>$</code></td></tr></tbody></table></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;I love HTML&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/HTML/</span>, <span class="string">&quot;$&amp; and JavaScript&quot;</span>) ); <span class="comment">// I love HTML and JavaScript</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;I love HTML&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/HTML/</span>, <span class="string">&quot;$` and JavaScript&quot;</span>) ); <span class="comment">// I love I love  and JavaScript</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;I love HTML&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/HTML/</span>, <span class="string">&quot;$&#x27; and JavaScript&quot;</span>) ); <span class="comment">//I love I love  and JavaScript</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><code>regexp.test(str)</code> 方法寻找至少一个匹配项，如果找到了，则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/LOVE/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( regexp.<span class="title function_">test</span>(str) ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p><strong>字符类（Character classes）</strong> 是一种特殊的符号，匹配特定集合中的任何符号。</p><p>最常用的是：</p><ul><li><p><code>\d</code>（“d” 来自 “digit”）</p><p>数字：从 <code>0</code> 到 <code>9</code> 的字符。</p></li><li><p><code>\s</code>（“s” 来自 “space”）</p><p>空格符号：包括空格，制表符 <code>\t</code>，换行符 <code>\n</code> 和其他少数稀有字符，例如 <code>\v</code>、<code>\f</code> 和 <code>\r</code>。</p></li><li><p><code>\w</code>（“w” 来自 “word”）</p></li></ul><p>“单字”字符：拉丁字母或数字或下划线 <code>_</code>。非拉丁字母不属于 <code>\w</code>。</p><p>例如，<code>\d\s\w</code> 表示“数字”，后跟“空格字符”，后跟“单字字符”，例如 <code>1 a</code>。</p><p>对于每个字符类，都有一个“反向类”，用相同的字母表示，但是大写的。</p><p>“反向”表示它与所有其他字符匹配，例如：</p><ul><li><p><code>\D</code></p><p>非数字：除 <code>\d</code> 以外的任何字符，例如字母。</p></li><li><p><code>\S</code></p><p>非空格符号：除 <code>\s</code> 以外的任何字符，例如字母。</p></li><li><p><code>\W</code></p><p>非单字字符：除 <code>\w</code> 以外的任何字符，例如非拉丁字母或空格。</p></li></ul><p>从 <code>+7(903)-123-45-67</code> 这样的字符串中创建一个只包含数字的电话号码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;+7(903)-123-45-67&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d/g</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) ); <span class="comment">// 79031234567</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">replace</span>(<span class="regexp">/\D/g</span>, <span class="string">&quot;&quot;</span>) ); <span class="comment">// 79031234567</span></span><br></pre></td></tr></table></figure><h3 id="匹配任意字符的"><a href="#匹配任意字符的" class="headerlink" title="匹配任意字符的."></a>匹配任意字符的<code>.</code></h3><p>点 <code>.</code> 是一种特殊字符类，它与“除换行符之外的任何字符”匹配。点不是缺少字符，我们必须有一个字符和点匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/CS.4/</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;CSS4&quot;</span>.<span class="title function_">match</span>(regexp) ); <span class="comment">// CSS4</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;CS-4&quot;</span>.<span class="title function_">match</span>(regexp) ); <span class="comment">// CS-4</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;CS 4&quot;</span>.<span class="title function_">match</span>(regexp) ); <span class="comment">// CS 4（空格也是一个字符）</span></span><br></pre></td></tr></table></figure><p>之前提到过<code>s</code>的作用是启用 “dotall” 模式，允许点 <code>.</code> 匹配换行符 <code>\n</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;A\nB&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/A.B/</span>s) ); <span class="comment">// A\nB（匹配了！）</span></span><br></pre></td></tr></table></figure><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>插入符号 <code>^</code> 和美元符号 <script type="math/tex">` 在正则表达式中具有特殊的含义。它们被称为“锚点”。（这里的`</script>和replace()中的<code>$</code>作用不同。）</p><p>插入符号 <code>^</code> 匹配文本开头，而 <script type="math/tex">` 则匹配文本末尾。两个锚点 `^...</script> 放在一起通常被用于测试一个字符串是否完全匹配一个模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;Mary had a little lamb&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>( <span class="regexp">/^Mary/</span>.<span class="title function_">test</span>(str1) ); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;it&#x27;s fleece was white as snow&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>( <span class="regexp">/snow$/</span>.<span class="title function_">test</span>(str1) ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="多行模式"><a href="#多行模式" class="headerlink" title="多行模式"></a>多行模式</h3><p>锚点的多行模式由修饰符<code>m</code>启用。</p><p>它只影响<code>^</code>和<code>$</code>的行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`1st place: Winnie</span></span><br><span class="line"><span class="string">2nd place: Piglet</span></span><br><span class="line"><span class="string">3rd place: Eeyore`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">match</span>(<span class="regexp">/^\d/gm</span>) ); <span class="comment">// 1, 2, 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">match</span>(<span class="regexp">/^\d/g</span>) ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`Winnie: 1</span></span><br><span class="line"><span class="string">Piglet: 2</span></span><br><span class="line"><span class="string">Eeyore: 3`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d\n/g</span>) ); <span class="comment">// 1\n,2\n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d$/gm</span>) ); <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><h3 id="词边界"><a href="#词边界" class="headerlink" title="词边界"></a>词边界</h3><p>词边界 <code>\b</code> 是一种检查，就像 <code>^</code> 和 <code>$</code> 一样。</p><p>有三种不同的位置可作为词边界：</p><ul><li>在字符串开头，如果第一个字符是单词字符 <code>\w</code>。</li><li>在字符串中的两个字符之间，其中一个是单词字符 <code>\w</code>，另一个不是。</li><li>在字符串末尾，如果最后一个字符是单词字符 <code>\w</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Hello, Java!&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\bHello\b/</span>) ); <span class="comment">// Hello</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Hello, Java!&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\bJava\b/</span>) );  <span class="comment">// Java</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Hello, Java!&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\bHell\b/</span>) );  <span class="comment">// null（无匹配项）</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Hello, Java!&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\bJava!\b/</span>) ); <span class="comment">// null（无匹配项）</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;1 23 456 78&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\b\d\d\b/g</span>) ); <span class="comment">// 23,78</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;12,34,56&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\b\d\d\b/g</span>) ); <span class="comment">// 12,34,56</span></span><br></pre></td></tr></table></figure><h2 id="转义与特殊字符"><a href="#转义与特殊字符" class="headerlink" title="转义与特殊字符"></a>转义与特殊字符</h2><ul><li>要在字面意义上搜索特殊字符 <code>[ \ ^ $ . | ? * + ( )</code>，我们需要在它们前面加上一个反斜杠 <code>\</code>（“转义它们”）。</li><li>如果在 <code>/.../</code> 内（但不在 <code>new RegExp</code> 内），我们还需要转义 <code>/</code>。</li><li>当将字符串传递给给 <code>new RegExp</code> 时，我们需要双反斜杠 <code>\\</code>，因为字符串引号会消耗一个反斜杠。</li></ul><h2 id="集合与范围"><a href="#集合与范围" class="headerlink" title="集合与范围"></a>集合与范围</h2><p>在方括号 <code>[…]</code> 中的几个字符或者字符类表示“搜索给定字符中的任意一个”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找 [t 或 m]，然后匹配 &quot;op&quot;</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Mop top&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/[tm]op/gi</span>) ); <span class="comment">// &quot;Mop&quot;, &quot;top&quot;</span></span><br><span class="line"><span class="comment">// 查找 &quot;V&quot;，然后匹配 [o 或 i]，之后匹配 &quot;la&quot;</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Voila&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/V[oi]la/</span>) ); <span class="comment">// null，无匹配项</span></span><br></pre></td></tr></table></figure><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>方括号也可以包含字符范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Exception 0xAF&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/x[0-9A-F][0-9A-F]/g</span>) ); <span class="comment">// xAF</span></span><br></pre></td></tr></table></figure><p>如果我们还想查找小写字母，则可以添加范围 <code>a-f</code>：<code>[0-9A-Fa-f]</code>。或添加标志 <code>i</code>。</p><p>我们也可以在 <code>[…]</code> 中使用字符类。</p><p>例如，如果我们想查找单词字符 <code>\w</code> 或连字符 <code>-</code>，则集合可以写为 <code>[\w-]</code>。</p><p>字符类其实是某些字符集合的缩写，例如：</p><ul><li><strong>\d</strong> —— 和 <code>[0-9]</code> 相同，</li><li><strong>\w</strong> —— 和 <code>[a-zA-Z0-9_]</code> 相同，</li><li><strong>\s</strong> —— 和 <code>[\t\n\v\f\r ]</code> 外加少量罕见的 Unicode 空格字符相同。</li></ul><h3 id="排除范围"><a href="#排除范围" class="headerlink" title="排除范围"></a>排除范围</h3><p>除了普通的范围匹配，还有像这样 <code>[^…]</code> 的“排除”范围匹配。</p><p>通过在开头添加插入符号 <code>^</code> 来表示匹配所有 <strong>除了给定的字符</strong> 之外的任意字符。</p><p>例如：</p><ul><li><code>[^aeyo]</code> —— 匹配除了 <code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;y&#39;</code> 或 <code>&#39;o&#39;</code> 之外的任何字符。</li><li><code>[^0-9]</code> —— 匹配除了数字之外的任何字符，与 <code>\D</code> 作用相同。</li><li><code>[^\s]</code> —— 匹配任何非空格字符，与 <code>\S</code> 作用相同。</li></ul><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><h3 id="n"><a href="#n" class="headerlink" title="{n}"></a>{n}</h3><p>在字符、字符类或集合后附加一个<code>&#123;n&#125;</code>，用来指出我们具体需要的数量。</p><p><code>\d&#123;5&#125;</code> 表示 5 位数，与 <code>\d\d\d\d\d</code> 相同。</p><p><strong>范围：</strong><code>&#123;3,5&#125;</code>，匹配 3-5 个</p><p>我们可以省略上限，那么正则表达式 <code>\d&#123;3,&#125;</code> 就会查找位数大于等于 <code>3</code> 的数字：</p><p>我们如果需要一个及以上的数字，就使用 <code>\d&#123;1,&#125;</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;+7(903)-123-45-67&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = str.<span class="title function_">match</span>(<span class="regexp">/\d&#123;1,&#125;/g</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(numbers); <span class="comment">// 7,903,123,45,67</span></span><br></pre></td></tr></table></figure><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p>大多数常用量词都有缩写形式。（缩写都是针对前面的字符）</p><h4 id=""><a href="#" class="headerlink" title="+"></a><code>+</code></h4><p>代表一个或多个，与<code>&#123;1,&#125;</code>相同。</p><p>例如，<code>\d+</code> 用来查找所有数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;+7(903)-123-45-67&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d+/g</span>) ); <span class="comment">// 7,903,123,45,67</span></span><br></pre></td></tr></table></figure><h4 id="-1"><a href="#-1" class="headerlink" title="?"></a><code>?</code></h4><p>代表一个或零个，与<code>&#123;0,1&#125;</code>相同。</p><p>所以 <code>colou?r</code> 会找到 <code>color</code> 和 <code>colour</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Should I write color or colour?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/colou?r/g</span>) ); <span class="comment">// color, colour</span></span><br></pre></td></tr></table></figure><h4 id="-2"><a href="#-2" class="headerlink" title="*"></a><code>*</code></h4><p>代表“零个及以上”，与 <code>&#123;0,&#125;</code> 相同。</p><p>例如，<code>\d0*</code> 查找一个数字后面跟着任意数量的零（可能有很多或没有）的数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;100 10 1&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\d0*/g</span>) ); <span class="comment">// 100, 10, 1</span></span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>量词是构成复杂正则表达式的主要“模块”。</p><ul><li>小数：<code>\d+\.\d+</code></li><li>HTML标签：<code>/&lt;[a-z]+&gt;/i</code> <code>/&lt;[a-z][a-z0-9]*&gt;/i</code> <code>/&lt;\/?[a-z][a-z0-9]\*&gt;/i</code></li><li>“…”(任意三个字符)：<code>/\.&#123;3,&#125;/g</code></li><li><code>#</code>开头的颜色值：<code>/#[0-9a-f]&#123;6&#125;\b/gi</code></li></ul><h2 id="贪婪量词与惰性量词"><a href="#贪婪量词与惰性量词" class="headerlink" title="贪婪量词与惰性量词"></a>贪婪量词与惰性量词</h2><p>量词功能十分强大，但也会产生一些让人困惑的问题。</p><p>比如说有一个文本，我们需要用书名号：<code>«...»</code> 来代替所有的引号 <code>&quot;...&quot;</code>。</p><p>首先想到的写法是使用<code>.+</code>匹配<code>&quot;</code>中的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/&quot;.+&quot;/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;a &quot;witch&quot; and her &quot;broom&quot; is one&#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(regexp) ); <span class="comment">// &quot;witch&quot; and her &quot;broom&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到预期结果与想象中的不同。这是因为正则在查找时采用了贪婪算法。</p><ol><li><p>该模式的第一个字符是一个引号 <code>&quot;</code>。</p><p>正则表达式引擎尝试在源字符串 <code>a &quot;witch&quot; and her &quot;broom&quot; is one</code> 的位置 0 找到它，但那里有 <code>a</code>，所以匹配失败。</p><p>然后继续前进：移至源字符串中的下一个位置，并尝试匹配模式中的第一个字符，再次失败，最终在第三个位置匹配到了引号：</p><p>a ==”==witch” and her “broom” is one</p></li><li><p>找到引号后，引擎就尝试去匹配模式中的剩余字符。它尝试查看剩余的字符串是否符合 <code>.+&quot;</code>。</p><p>在我们的用例中，模式中的下一个字符为 <code>.</code>（一个点）。它表示匹配除了换行符之外的任意字符，所以将会匹配下一个字符 <code>&#39;w&#39;</code>：</p><p>a ==”w==itch” and her “broom” is one</p></li><li><p>然后由于量词 <code>.+</code>，点会重复。正则表达式引擎一个接一个字符地进行匹配。</p><p>……什么时候会不匹配？点（.）能够匹配所有字符，所以只有在移至字符串末尾时才停止匹配：</p><p>a ==”witch” and her “broom” is one==</p></li><li><p>现在引擎完成了对重复模式 <code>.+</code> 的搜索，并且试图寻找模式中的下一个字符。是引号 <code>&quot;</code>。但是有一个问题：对字符串的遍历已经结束，没有更多字符了！</p><p>正则表达式引擎知道它为 <code>.+</code> 匹配太多项了，所以开始 <strong>回溯</strong>。</p><p>换句话说，它去掉了量词匹配项的最后一个字符：</p><p>a ==”witch” and her “broom” is on==e</p><p>现在它假设 <code>.+</code> 的匹配在字符串的倒数第一个字符前的位置结束，并尝试从该位置匹配模式的剩余部分。</p><p>如果那里有引号，则搜索将结束，但最后一个字符是 <code>&#39;e&#39;</code>，所以不匹配。</p></li><li><p>……所以引擎会将 <code>.+</code> 的重复次数减少一个字符：</p><p>引号 <code>&#39;&quot;&#39;</code> 与 <code>&#39;n&#39;</code> 不匹配。</p></li><li><p>引擎不断进行回溯：它减少 <code>&#39;.&#39;</code> 的重复次数，直到模式的其余部分（在我们的用例中是 <code>&#39;&quot;&#39;</code>）匹配到结果：</p></li></ol><p>​        a ==”witch” and her “broom”== is one 匹配完成。</p><p>所以，第一次匹配项是 <code>&quot;witch&quot; and her &quot;broom&quot;</code>。如果正则表达式具有修饰符 <code>g</code>，则搜索将从第一个匹配结束的地方继续。字符串 <code>is one</code> 的剩余部分不再有引号，因此没有更多匹配项。</p><h3 id="惰性模式"><a href="#惰性模式" class="headerlink" title="惰性模式"></a>惰性模式</h3><p>我们可以通过在量词后面加一个<code>?</code>来启用惰性模式，这样搜索过程将转变为：</p><ol><li><p>第一步是一样的：它在第三个字符的位置找到了模式的开头 <code>&#39;&quot;&#39;</code>： a ==”==witch” and her “broom” is one</p></li><li><p>下一步也是类似的：引擎为 <code>&#39;.&#39;</code> 找到了一个匹配项： a ==”w==itch” and her “broom” is one</p></li><li><p>接下来的搜索就有些不同了。因为我们对 <code>+?</code> 启用了惰性模式，引擎不会去尝试多匹配一个点的匹配字符，而会停止并<strong>立即尝试对剩余的模式 <code>&#39;&quot;&#39;</code> 进行匹配</strong>： a ==”w==itch” and her “broom” is one</p><p>如果这里有一个引号，搜索就会停止，但这里是一个 <code>&#39;i&#39;</code>，所以没有匹配到引号。</p></li><li><p>接着，正则表达式引擎增加对点的重复搜索次数，并且再次尝试： a ==”wi==tch” and her “broom” is one</p><p>又失败了。然后重复次数一次又一次的增加……</p></li><li><p>……直到找到了模式中的剩余部分的匹配项： a ==”witch”== and her “broom” is one</p></li><li><p>接下来的搜索从当前匹配的结尾开始，并产生了下一个匹配项： a ==”witch”== and her ==”broom”== is one</p></li></ol><p>在这个例子中，我们看到了惰性模式的 <code>+?</code> 是怎样工作的。量词 <code>*?</code> 和 <code>??</code> 的工作方式类似 —— 正则表达式引擎仅在模式的其余部分无法在给定位置匹配时增加重复次数。</p><p>另一个惰性模式的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;123 456&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\d+ \d+?/</span>) ); <span class="comment">// 123 4</span></span><br></pre></td></tr></table></figure><h3 id="替代方法"><a href="#替代方法" class="headerlink" title="替代方法"></a>替代方法</h3><p>上面这个例子还有一个替代的正则表达式：<code>/&quot;[^&quot;]+&quot;/g</code></p><h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><p>模式的一部分可以使用<code>()</code>括起来，这被称为捕获组(capturing group)，捕获组有两个影响：</p><ul><li>它允许将匹配的一部分作为结果数组中的单独项。</li><li>如果我们将量词放在括号后，则它将括号视为一个整体。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="gogogo"><a href="#gogogo" class="headerlink" title="gogogo"></a><code>gogogo</code></h4><p>不带括号，模式 <code>go+</code> 表示 <code>g</code> 字符，其后 <code>o</code> 重复一次或多次。例如 <code>goooo</code> 或 <code>gooooooooo</code>。</p><p>括号将字符组合，所以 <code>(go)+</code> 匹配 <code>go</code>，<code>gogo</code>，<code>gogogo</code>等。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mail.com</span><br><span class="line">users.mail.com</span><br><span class="line">smith.users.mail.com</span><br></pre></td></tr></table></figure><p>域名是由单词加点组成的，除了最后一个单词</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(\w+\.)+\w+/g</span>;</span><br></pre></td></tr></table></figure><h4 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h4><p>电子邮件的格式为<code>name@domain</code>。名称可以是任何单词，允许使用连字符和点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/[-.\w]+@([\w-]+\.)+[\w-]+/g</span>;</span><br></pre></td></tr></table></figure><p>这里<code>[]</code>中的<code>.</code>可以不用转义，但<code>()</code>中的<code>.</code>需要转义。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>方括号只允许字符或字符类。选择允许任何表达式。正则表达式 <code>A|B|C</code> 表示表达式 <code>A</code>、<code>B</code> 或 <code>C</code> 其一均可。</p><p>例如：</p><ul><li><code>gr(a|e)y</code> 等同于 <code>gr[ae]y</code>。</li><li><code>gra|ey</code> 表示 <code>gra</code> 或 <code>ey</code>。</li></ul><p>要将选择应用于模式中一部分内容的选择，我们可以将其括在括号中：</p><ul><li><code>I love HTML|CSS</code> 匹配 <code>I love HTML</code> 或 <code>CSS</code>。</li><li><code>I love (HTML|CSS)</code> 匹配 <code>I love HTML</code> 或 <code>I love CSS</code>。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>时间匹配的正则表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/([01]\d|2[0-3]):[0-5]\d/g</span>;</span><br></pre></td></tr></table></figure><h2 id="前瞻断言与后瞻断言"><a href="#前瞻断言与后瞻断言" class="headerlink" title="前瞻断言与后瞻断言"></a>前瞻断言与后瞻断言</h2><p>有时我们需要为一个模式找到那些在另一个模式之后或之前的匹配项。</p><h3 id="前瞻断言"><a href="#前瞻断言" class="headerlink" title="前瞻断言"></a>前瞻断言</h3><p>语法为：<code>x(?=y)</code>，它表示“仅在后面是 <code>Y</code> 时匹配 <code>X</code>”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1 turkey costs 30€&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d+(?=€)/</span>) ); <span class="comment">// 30，数字 1 被忽略了，因为它后面没有 €</span></span><br></pre></td></tr></table></figure><p><code>\d+(?=\s)(?=.*30)</code> 查找后跟着空格 <code>(?=\s)</code> 的 <code>\d+</code>，并且有 <code>30</code> 在它之后的某个地方 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1 turkey costs 30€&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d+(?=\s)(?=.*30)/</span>) ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="否定前瞻断言"><a href="#否定前瞻断言" class="headerlink" title="否定前瞻断言"></a>否定前瞻断言</h3><p>语法是：<code>X(?!Y)</code>，意思是“搜索 <code>X</code>，但前提是后面没有 <code>Y</code>”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;2 turkeys cost 60€&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d+\b(?!€)/g</span>) ); <span class="comment">// 2（价格不匹配）</span></span><br></pre></td></tr></table></figure><h3 id="后瞻断言"><a href="#后瞻断言" class="headerlink" title="后瞻断言"></a>后瞻断言</h3><p>前瞻断言允许添加一个“后面要跟着什么”的条件判断。</p><p>后瞻断言也类似，只不过它是在相反的方向上进行条件判断。也就是说，它只允许匹配前面有特定字符串的模式。</p><p>语法为如下：</p><ul><li>肯定的后瞻断言：<code>(?&lt;=Y)X</code>，匹配 <code>X</code>，仅在前面是 <code>Y</code> 的情况下。</li><li>否定的后瞻断言：<code>(?&lt;!Y)X</code>，匹配 <code>X</code>，仅在前面不是 <code>Y</code> 的情况下。</li></ul><p>使用 <code>(?&lt;=\$)\d+</code> —— 一个前面带 <code>$</code> 的数值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1 turkey costs $30&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 美元符号被转义 \$</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/(?&lt;=\$)\d+/</span>) ); <span class="comment">// 30（跳过了仅仅是数字的值）</span></span><br></pre></td></tr></table></figure><p>我们可以使用否定的后瞻断言：<code>(?&lt;!\$)\d+</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;2 turkeys cost $60&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/(?&lt;!\$)\b\d+/g</span>) ); <span class="comment">// 2（价格不匹配）</span></span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>选择非负整数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/\b(?&lt;!-)\d+\b/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;0 12 -5 123 -18&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">match</span>(regexp) ); <span class="comment">// 0, 12, 123</span></span><br></pre></td></tr></table></figure><h1 id="Java正则"><a href="#Java正则" class="headerlink" title="Java正则"></a>Java正则</h1><p>对Java正则来说，主要包括以下三个类：</p><ul><li><p>Pattern 类：</p><p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p></li><li><p>Matcher 类：</p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p></li><li><p>PatternSyntaxException：</p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexMatches</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 按指定模式在字符串查找</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;This order was placed for QT3000! OK?&quot;</span>;</span><br><span class="line">      <span class="comment">// 找一个包含数字的字符串</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;(\\D*)(\\d+)(.*)&quot;</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 创建 Pattern 对象</span></span><br><span class="line">      <span class="type">Pattern</span> <span class="variable">r</span> <span class="operator">=</span> Pattern.compile(pattern);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 现在创建 matcher 对象</span></span><br><span class="line">      <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> r.matcher(line);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，<code>\\</code>表示我要插入一个具有特殊意义的正则表达式的反斜线，而在JS等很多其他语言中，<code>\</code>就能达到相同的效果。</p><p>下面是Matcher类的一些方法：</p><h2 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h2><p>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>序号</strong></th><th style="text-align:left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public int start()</strong> 返回以前匹配的初始索引。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public int start(int group)</strong>  返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public int end()</strong> 返回最后匹配字符之后的偏移量。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public int end(int group)</strong> 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td></tr></tbody></table></div><h2 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h2><p>查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>序号</strong></th><th style="text-align:left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public boolean lookingAt()</strong>  尝试将从区域开头开始的输入序列与该模式匹配。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public boolean find()</strong> 尝试查找与该模式匹配的输入序列的下一个子序列。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public boolean find(int start**</strong>）** 重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public boolean matches()</strong> 尝试将整个区域与模式匹配。</td></tr></tbody></table></div><h2 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h2><p>替换方法是替换输入字符串里文本的方法：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>序号</strong></th><th style="text-align:left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public Matcher appendReplacement(StringBuffer sb, String replacement)</strong> 实现非终端添加和替换步骤。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public StringBuffer appendTail(StringBuffer sb)</strong> 实现终端添加和替换步骤。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public String replaceAll(String replacement)</strong>  替换模式与给定替换字符串相匹配的输入序列的每个子序列。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public String replaceFirst(String replacement)</strong>  替换模式与给定替换字符串匹配的输入序列的第一个子序列。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>public static String quoteReplacement(String s)</strong> 返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"平畴的博客","short_name":"平畴的博客","theme_color":"#49b1f5","background_color":"#49b1f5","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: 'ZhuZiAYuanJWD';  }  h1#site-title {    /* font-family: ZhuZiAYuanJWD; */    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: 'iconfont' !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  .bangumi-active {    background: #dbecfe !important;    border-radius: 10px !important;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: #dbecfe !important;    border-radius: 10px !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme='dark'] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme='dark'] .card-widget {    background: #121212 !important;  }    [data-theme='dark'] div#post {    background: #121212 !important;  }    [data-theme='dark'] div#tag {    background: #121212 !important;  }    [data-theme='dark'] div#archive {    background: #121212 !important;  }    [data-theme='dark'] div#page {    background: #121212 !important;  }    [data-theme='dark'] div#category {    background: #121212 !important;  }    [data-theme='dark'] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }    #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #49b1f5;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #49b1f5;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* 鼠标图标 */  body {    cursor: url('/img/x1.cur'), auto;  }  a,  [type='button']:not(:disabled),  [type='reset']:not(:disabled),  [type='submit']:not(:disabled),  button:not(:disabled) {    cursor: url('/img/x2.cur'), auto !important;  }  /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #49b1f5;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft JhengHei', 'Microsoft YaHei', sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--heo-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }  ]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
