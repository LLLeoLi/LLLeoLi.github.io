<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>语法分析</title>
      <link href="/posts/dafc.html"/>
      <url>/posts/dafc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在我们的编译器模型中，语法分析器从词法分析器获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成。我们期望语法分析器能够以易于理解的方式报告语法错误，并且能够从常见的错误中恢复并继续处理程序的其余部分。</p><p>——《编译原理》（龙书）</p></blockquote><h1 id="语法分析设计"><a href="#语法分析设计" class="headerlink" title="语法分析设计"></a>语法分析设计</h1><p>在本次实验中，我采用了自底向上生成和自顶向下输出的方式，利用递归子程序对文法中定义的语法成分进行了分析和输出。本次实验的难点有：语法树的设计、消除左递归、不同语法类型判断。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><h3 id="编码前"><a href="#编码前" class="headerlink" title="编码前"></a>编码前</h3><p>为了方便之后对语法节点的调用，本次实验将每个语法成分作为AST中的一个类进行存储，其中Node为抽象父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>Ident</code>，<code>FormatString</code>和<code>IntConst</code>，则将其作为<code>Token</code>的子类，方便进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showToken() <span class="keyword">instanceof</span> Ident</span><br></pre></td></tr></table></figure><p>使用<code>showToken()</code>预读取当前的<code>Token</code>，使用<code>getToken()</code>获取当前<code>Token</code>，暂时使用<code>error()</code>输出对应错误的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Token <span class="title function_">showToken</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tokens.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> Token <span class="title function_">showToken</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tokens.get(index+num);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--Error--&quot;</span>+str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="编码后"><a href="#编码后" class="headerlink" title="编码后"></a>编码后</h3><p>在语法分析中首先对out进行了重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> <span class="string">&quot;output.txt&quot;</span>;</span><br><span class="line"><span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(output);</span><br><span class="line">System.setOut(out);</span><br></pre></td></tr></table></figure><p>对于每个节点来说，大致设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompUnit</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Decl&gt; decl;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;FuncDef&gt; funcDef;</span><br><span class="line">    <span class="keyword">private</span> MainFuncDef mainFuncDef;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CompUnit</span><span class="params">(ArrayList&lt;Decl&gt; decl, ArrayList&lt;FuncDef&gt; funcDef, MainFuncDef mainFuncDef)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decl = decl;</span><br><span class="line">        <span class="built_in">this</span>.funcDef = funcDef;</span><br><span class="line">        <span class="built_in">this</span>.mainFuncDef = mainFuncDef;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意这里是print而非println</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Decl value : decl)&#123;</span><br><span class="line">            value.output();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(FuncDef value : funcDef)&#123;</span><br><span class="line">            value.output();</span><br><span class="line">        &#125;</span><br><span class="line">        mainFuncDef.output();</span><br><span class="line">        System.out.print(<span class="string">&quot;&lt;CompUnit&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuncDef</span> <span class="keyword">extends</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    FuncType funcType;</span><br><span class="line">    Ident funcName;</span><br><span class="line">    Token left;</span><br><span class="line">    FuncFParams params;</span><br><span class="line">    Token right;</span><br><span class="line">    Block block;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FuncDef</span><span class="params">(FuncType funcType, Ident funcName, Token left, FuncFParams params, Token right, Block block)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.funcType = funcType;</span><br><span class="line">        <span class="built_in">this</span>.funcName = funcName;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.params = params;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">        <span class="built_in">this</span>.block = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">       funcType.output();</span><br><span class="line">       funcName.output();</span><br><span class="line">       left.output();</span><br><span class="line">       <span class="keyword">if</span>(Objects.nonNull(params)) params.output();</span><br><span class="line">       right.output();</span><br><span class="line">       block.output();</span><br><span class="line">       System.out.println(<span class="string">&quot;&lt;FuncDef&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="当前项目架构"><a href="#当前项目架构" class="headerlink" title="当前项目架构"></a>当前项目架构</h3><p>项目架构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">│  Compiler.java</span><br><span class="line">│</span><br><span class="line">├─frontend</span><br><span class="line">│  ├─lexical</span><br><span class="line">│  │  │  Token.java</span><br><span class="line">│  │  │  Tokenizer.java</span><br><span class="line">│  │  │  TokenList.java</span><br><span class="line">│  │  │</span><br><span class="line">│  │  └─tokens</span><br><span class="line">│  │          FormatString.java</span><br><span class="line">│  │          Ident.java</span><br><span class="line">│  │          IntConst.java</span><br><span class="line">│  │</span><br><span class="line">│  └─syntax</span><br><span class="line">│      │  Parser.java</span><br><span class="line">│      │</span><br><span class="line">│      └─AST</span><br><span class="line">│              AddExp.java</span><br><span class="line">│              Block.java</span><br><span class="line">│              BlockItem.java</span><br><span class="line">│              CompUnit.java</span><br><span class="line">│              Cond.java</span><br><span class="line">│              ConstDecl.java</span><br><span class="line">│              ConstDef.java</span><br><span class="line">│              ConstExp.java</span><br><span class="line">│              ConstInitVal.java</span><br><span class="line">│              Decl.java</span><br><span class="line">│              EqExp.java</span><br><span class="line">│              Exp.java</span><br><span class="line">│              FuncDef.java</span><br><span class="line">│              FuncFParam.java</span><br><span class="line">│              FuncFParams.java</span><br><span class="line">│              FuncRParams.java</span><br><span class="line">│              FuncType.java</span><br><span class="line">│              InitVal.java</span><br><span class="line">│              LAndExp.java</span><br><span class="line">│              LOrExp.java</span><br><span class="line">│              LVal.java</span><br><span class="line">│              MainFuncDef.java</span><br><span class="line">│              MulExp.java</span><br><span class="line">│              Node.java</span><br><span class="line">│              Number.java</span><br><span class="line">│              PrimaryExp.java</span><br><span class="line">│              RelExp.java</span><br><span class="line">│              Stmt.java</span><br><span class="line">│              UnaryExp.java</span><br><span class="line">│              UnaryOp.java</span><br><span class="line">│              VarDecl.java</span><br><span class="line">│              VarDef.java</span><br><span class="line">│</span><br><span class="line">└─utils</span><br><span class="line">        Source.java</span><br></pre></td></tr></table></figure><p>在设计时，我们可以先完成与<code>funcDef</code>和<code>MainFuncDef</code>相关的类，之后完成与<code>Decl</code>相关的类，再完成与<code>Block</code>相关的类，最后完成<code>Stmt</code>相关的类。并随着类的编写不断拓展完善自己的测试用例。</p><p>当前Compiler类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">Source</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Source</span>();</span><br><span class="line">        Tokenizer.initToken(source);</span><br><span class="line">        <span class="type">Parser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parser</span>(Tokenizer.getTokenList());</span><br><span class="line">        parser.analyse().output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h2><p>对于以下文法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">乘除模表达式 MulExp → UnaryExp | MulExp (<span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> | <span class="string">&#x27;%&#x27;</span>) UnaryExp</span><br><span class="line"></span><br><span class="line">加减表达式 AddExp → MulExp | AddExp (<span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;−&#x27;</span>) MulExp</span><br><span class="line"></span><br><span class="line">关系表达式 RelExp → AddExp | RelExp (<span class="string">&#x27;&lt;&#x27;</span> | <span class="string">&#x27;&gt;&#x27;</span> | <span class="string">&#x27;&lt;=&#x27;</span> | <span class="string">&#x27;&gt;=&#x27;</span>) AddExp</span><br><span class="line"></span><br><span class="line">相等性表达式 EqExp → RelExp | EqExp (<span class="string">&#x27;==&#x27;</span> | <span class="string">&#x27;!=&#x27;</span>) RelExp</span><br><span class="line"></span><br><span class="line">逻辑与表达式 LAndExp → EqExp | LAndExp <span class="string">&#x27;&amp;&amp;&#x27;</span> EqExp</span><br><span class="line"></span><br><span class="line">逻辑或表达式 LOrExp → LAndExp | LOrExp <span class="string">&#x27;||&#x27;</span> LAndExp</span><br></pre></td></tr></table></figure><p>我们可以对其进行改写，消除文法的左递归性。</p><p>以<code>MulExp</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MulExp → UnaryExp | MulExp (&#x27;*&#x27; | &#x27;/&#x27; | &#x27;%&#x27;) UnaryExp</span></span><br><span class="line"><span class="comment"> * 可将文法改写为 MulExp → UnaryExp &#123; (&#x27;*&#x27; | &#x27;/&#x27; | &#x27;%&#x27;) UnaryExp &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> MulExp <span class="title function_">getMulExp</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;UnaryExp&gt; params = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Token&gt; tokens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    params.add(getUnaryExp());</span><br><span class="line">    <span class="keyword">while</span>(showToken().getContent().equals(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">          ||showToken().getContent().equals(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">          ||showToken().getContent().equals(<span class="string">&quot;%&quot;</span>))&#123;</span><br><span class="line">        tokens.add(getToken());</span><br><span class="line">        params.add(getUnaryExp());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MulExp</span>(params,tokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们对文法进行了修改，所以要特别注意要按照原文法进行输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; params.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>) tokens.get(i-<span class="number">1</span>).output();</span><br><span class="line">        params.get(i).output();</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;MulExp&gt;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语法类型判断"><a href="#语法类型判断" class="headerlink" title="语法类型判断"></a>语法类型判断</h2><h3 id="VarDef"><a href="#VarDef" class="headerlink" title="VarDef"></a><code>VarDef</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VarDef → Ident &#123; <span class="string">&#x27;[&#x27;</span> ConstExp <span class="string">&#x27;]&#x27;</span> &#125; | Ident &#123; <span class="string">&#x27;[&#x27;</span> ConstExp <span class="string">&#x27;]&#x27;</span> &#125; <span class="string">&#x27;=&#x27;</span> InitVal </span><br></pre></td></tr></table></figure><p>可以将文法改写为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VarDef → Ident &#123; <span class="string">&#x27;[&#x27;</span> ConstExp <span class="string">&#x27;]&#x27;</span> &#125; [ <span class="string">&#x27;=&#x27;</span> InitVal  ]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!showToken().getContent().equals(<span class="string">&quot;=&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VarDef</span>(<span class="number">1</span>,count, ident,lrs,constExps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">Token</span> <span class="variable">equal</span> <span class="operator">=</span> getToken();</span><br><span class="line">    <span class="type">InitVal</span> <span class="variable">varInitVal</span> <span class="operator">=</span> getInitVal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VarDef</span>(<span class="number">2</span>,count, ident,lrs,constExps,equal,varInitVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stmt"><a href="#Stmt" class="headerlink" title="Stmt"></a><code>Stmt</code></h3><p>对<code>Stmt</code>来说，需要注意<code>LVal &#39;=&#39; Exp &#39;;&#39;</code>和<code>[Exp] &#39;;&#39;</code>的FIRST集存在交集，可以采用先确定<code>&#39;;&#39;</code>位置，然后确定范围内是否存在<code>&#39;=&#39;</code>的方式进行判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">notExp</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!showToken(temp).getContent().equals(<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;temp;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(showToken(i).getContent().equals(<span class="string">&quot;=&quot;</span>)) notExp = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stmt → [Exp] &#x27;;&#x27;  [0,1]</span></span><br><span class="line"><span class="comment">     * | LVal &#x27;=&#x27; &#x27;getint&#x27;&#x27;(&#x27;&#x27;)&#x27;&#x27;;&#x27; [2]</span></span><br><span class="line"><span class="comment">     * | LVal &#x27;=&#x27; Exp &#x27;;&#x27; [3]</span></span><br><span class="line"><span class="comment">     * | Block [4]</span></span><br><span class="line"><span class="comment">     * | &#x27;if&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; Stmt [ &#x27;else&#x27; Stmt ] [5,6]</span></span><br><span class="line"><span class="comment">     * | &#x27;while&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; Stmt [7]</span></span><br><span class="line"><span class="comment">     * | &#x27;break&#x27; &#x27;;&#x27; [8]</span></span><br><span class="line"><span class="comment">     * | &#x27;continue&#x27; &#x27;;&#x27; [9]</span></span><br><span class="line"><span class="comment">     * | &#x27;return&#x27; [Exp] &#x27;;&#x27; [10,11]</span></span><br><span class="line"><span class="comment">     * | &#x27;printf&#x27;&#x27;(&#x27;FormatString&#123;&#x27;,&#x27;Exp&#125;&#x27;)&#x27;&#x27;;&#x27; [12]</span></span><br><span class="line"><span class="comment">     * 对LVal,有LVal → Ident &#123;&#x27;[&#x27; Exp &#x27;]&#x27;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次实验代码还有着不少可优化的空间，重构后应该会对博客内容进行更新。</p><p>感谢<a href="https://github.com/wxy4869">wxy4869 </a>de</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS数组</title>
      <link href="/posts/3519.html"/>
      <url>/posts/3519.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文简单介绍了一些常用的JS数组操作，内容较为零散。</p></blockquote><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="at"><a href="#at" class="headerlink" title="at"></a>at</h2><p>有些编程语言允许我们使用负数索引来实现获取数组的最后一个元素，但这在JS中行不通，在JS中，我们可以使用at：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 fruits[fruits.length-1] 相同</span></span><br><span class="line"><span class="title function_">alert</span>( fruits.<span class="title function_">at</span>(-<span class="number">1</span>) ); <span class="comment">// Plum</span></span><br></pre></td></tr></table></figure><p>换句话说，<code>arr.at(i)</code>：</p><ul><li>如果 <code>i &gt;= 0</code>，则与 <code>arr[i]</code> 完全相同。</li><li>对于 <code>i</code> 为负数的情况，它则从数组的尾部向前数。</li></ul><h2 id="增添元素"><a href="#增添元素" class="headerlink" title="增添元素"></a>增添元素</h2><ul><li><code>push(...items)</code> 在末端添加 <code>items</code> 项。</li><li><code>pop()</code> 从末端移除并返回该元素。</li><li><code>shift()</code> 从首端移除并返回该元素。</li><li><code>unshift(...items)</code> 从首端添加 <code>items</code> 项。</li></ul><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">splice</span>(start[, deleteCount, elem1, ..., elemN])</span><br></pre></td></tr></table></figure><p>从索引 <code>start</code> 开始修改 <code>arr</code>：删除 <code>deleteCount</code> 个元素并在当前位置插入 <code>elem1, ..., elemN</code>。最后返回被删除的元素所组成的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 从索引 1 开始删除 1 个元素</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Let&#x27;s&quot;</span>, <span class="string">&quot;dance&quot;</span>);</span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">0</span>,arr.<span class="property">length</span>);</span><br><span class="line">arr.<span class="title function_">splice</span>(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">slice</span>([start], [end])</span><br></pre></td></tr></table></figure><p>它会返回一个新数组，将所有从索引 <code>start</code> 到 <code>end</code>（不包括 <code>end</code>）的数组项复制到一个新的数组。<code>start</code> 和 <code>end</code> 都可以是负数，在这种情况下，从末尾计算索引。</p><p>我们也可以不带参数地调用它：<code>arr.slice()</code> 会创建一个 <code>arr</code> 的副本。其通常用于获取副本，以进行不影响原始数组的进一步转换。</p><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">concat</span>(arg1, arg2...)</span><br></pre></td></tr></table></figure><p>它接受任意数量的参数 —— 数组或值都可以。</p><p>结果是一个包含来自于 <code>arr</code>，然后是 <code>arg1</code>，<code>arg2</code> 的元素的新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">concat</span>([<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>) ); <span class="comment">// 1,2,3,4,5,6</span></span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>寻找一个匹配的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果返回 true，则返回 item 并停止迭代</span></span><br><span class="line">  <span class="comment">// 对于假值（falsy）的情况，则返回 undefined</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还有<code>findIndex</code>和<code>findLastIndex</code>返回匹配索引。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>寻找所有匹配的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results = arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果 true item 被 push 到 results，迭代继续</span></span><br><span class="line">  <span class="comment">// 如果什么都没找到，则返回空数组</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>最常用的方法，对每个元素都调用函数，然后返回结果数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回新值而不是当前元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>对原数组进行排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b );</span><br></pre></td></tr></table></figure><h2 id="split-join"><a href="#split-join" class="headerlink" title="split/join"></a>split/join</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = <span class="string">&#x27;Bilbo, Gandalf, Nazgul&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = names.<span class="title function_">split</span>(<span class="string">&#x27;, &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="string">`A message to <span class="subst">$&#123;name&#125;</span>.`</span> ); <span class="comment">// A message to Bilbo（和其他名字）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Bilbo&#x27;</span>, <span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;Nazgul&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = arr.<span class="title function_">join</span>(<span class="string">&#x27;;&#x27;</span>); <span class="comment">// 使用分号 ; 将数组粘合成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str ); <span class="comment">// Bilbo;Gandalf;Nazgul</span></span><br></pre></td></tr></table></figure><h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h2><p><code>Array.isArray(value)</code> 检查 <code>value</code> 是否是一个数组，如果是则返回 <code>true</code>，否则返回 <code>false</code>。</p><h1 id="数组的对象本质"><a href="#数组的对象本质" class="headerlink" title="数组的对象本质"></a>数组的对象本质</h1><p>在JS中只有8中基本数据类型，数组实际上是一种对象，真正特殊的是它们的内部实现。JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域，而且还有一些其它的优化，以使数组运行得非常快。但是，如果我们不像“有序集合”那样使用数组，而是像常规对象那样使用数组，这些就都不生效了。</p><p>下面的操作会使数组退化为对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = []; <span class="comment">// 创建一个数组</span></span><br><span class="line"></span><br><span class="line">fruits[<span class="number">99999</span>] = <span class="number">5</span>; <span class="comment">// 分配索引远大于数组长度的属性</span></span><br><span class="line"></span><br><span class="line">fruits.<span class="property">age</span> = <span class="number">25</span>; <span class="comment">// 创建一个具有任意名称的属性</span></span><br></pre></td></tr></table></figure><h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>为对象添加一个名为 <code>Symbol.iterator</code> 的方法（一个专门用于使对象可迭代的内建 symbol）。</p><p>这个方法需要返回一个有<code>next</code>方法的对象，其返回的结果格式必须为 <code>&#123;done: Boolean, value: any&#125;</code>，当 <code>done=true</code> 时，表示循环结束，否则 <code>value</code> 是下一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="attr">from</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">to</span>: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = <span class="variable language_">this</span>.<span class="property">from</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">current</span> &lt;= <span class="variable language_">this</span>.<span class="property">to</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">current</span>++ &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(num); <span class="comment">// 1, 然后是 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于可迭代或类数组（有索引和<code>length</code>属性）对象，我们可以使用<code>Array.from</code>得到一个真正的数组，之后便可以调用方便的数组方法。</p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>数组有三种循环方式：</p><ul><li><code>for (let i=0; i&lt;arr.length; i++)</code> — 运行得最快，可兼容旧版本浏览器。</li><li><code>for (let item of arr)</code> — （迭代器）现代语法，只能访问 items。</li><li><code>for (let i in arr)</code> — （对象）永远别用。</li></ul><h1 id="length"><a href="#length" class="headerlink" title="length"></a>length</h1><p>数组中的length属性其实是其最大的数字索引值加一，如果我们减少它，则数组会发生不可逆截断。</p><p>清空数组的最简单方式就是<code>arr.length = 0;</code></p><h1 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a><code>Object.keys(obj)</code></h1><p>对于对象来说，我们使用的调用语法是 <code>Object.keys(obj)</code>，而不是 <code>obj.keys()</code>。因为对象是所有复杂结构的基础。</p><p><code>Object.*</code> 方法返回的是“真正的”数组对象，而不只是一个可迭代对象。（虽然抽象程度变低了，但是是历史原因，就这样吧）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Object.keys(user) = [&quot;name&quot;, &quot;age&quot;]</code></li><li><code>Object.values(user) = [&quot;John&quot;, 30]</code></li><li><code>Object.entries(user) = [ [&quot;name&quot;,&quot;John&quot;], [&quot;age&quot;,30] ]</code></li></ul><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><ul><li><p>解构赋值可以简洁地将一个对象或数组拆开赋值到多个变量上。</p></li><li><p>解构对象的完整语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;prop : varName = <span class="keyword">default</span>, ...rest&#125; = object</span><br></pre></td></tr></table></figure><p>这表示属性 <code>prop</code> 会被赋值给变量 <code>varName</code>，如果没有这个属性的话，就会使用默认值 <code>default</code>。</p><p>没有对应映射的对象属性会被复制到 <code>rest</code> 对象。</p></li><li><p>解构数组的完整语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [item1 = <span class="keyword">default</span>, item2, ...rest] = array</span><br></pre></td></tr></table></figure><p>数组的第一个元素被赋值给 <code>item1</code>，第二个元素被赋值给 <code>item2</code>，剩下的所有元素被复制到另一个数组 <code>rest</code>。</p></li><li><p>从嵌套数组/对象中提取数据也是可以的，此时等号左侧必须和等号右侧有相同的结构。</p></li><li><p>对“数组”的解构赋值可以范围拓展到可迭代对象上，如Map，Set等。</p></li><li><pre><code class="lang-js">[guest, admin] = [admin, guest];// js用一行交换变量值</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词法分析</title>
      <link href="/posts/b0fd.html"/>
      <url>/posts/b0fd.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>词法分析是编译的第一阶段。主要任务是读入源程序的输入字符，将他们组成词素，生成并输出一个词法单元序列，每个词法对应于一个词素。这个词法单元序列被输出到语法分析器进行语法分析。词法分析器通常还要和符号表进行交互。</p><p>​                                                                                                                                                                                ——《编译原理》（龙书）</p></blockquote><h1 id="词法分析设计"><a href="#词法分析设计" class="headerlink" title="词法分析设计"></a>词法分析设计</h1><p>其实词法分析也就是对字符串的匹配问题。在实验中，我采用了以枚举类容纳正则表达式进行匹配的方式，涉及到的难点主要有：注释的处理、各类符号正则匹配。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>本次项目没有对编码前的设计进行修改。<br>目前项目架构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Compiler.java</span><br><span class="line">├── front</span><br><span class="line">└── token</span><br><span class="line">├── Tokenizer.java</span><br><span class="line">    ├── TokenList.java</span><br><span class="line">    └── Token.java</span><br><span class="line">└── utils</span><br><span class="line">    └── Input.java</span><br></pre></td></tr></table></figure><p>在<code>Input</code>类中，首先将文件按行存储到<code>ArrayList&lt;String&gt; lines</code>中，使用<code>getFollowingChars</code>函数实现从当前字符预读取n个字符，使用<code>goForward</code>函数实现每次前进n个字符，使用<code>match</code>函数进行正则匹配，使用<code>skipBlacks</code>函数跳过不可见字符。</p><p>在<code>Tokenizer</code>类中，通过<code>initToken</code>方法实现了程序主要功能。</p><h2 id="注释处理"><a href="#注释处理" class="headerlink" title="注释处理"></a>注释处理</h2><p>主要有两种形式的注释：</p><ul><li><code>//</code>：只要出现，那么就跳过当前行之后的所有字符。</li><li><code>/* ... */</code>：出现<code>/*</code>后，先向前2个字符（此刻对应字符为<code>/</code>），不断逐字符匹配，直到匹配到<code>*/</code>为止，并忽略期间的所有字符。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tokenizer</span> &#123;</span><br><span class="line">    <span class="comment">// source中存储了所有的lines</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initToken</span><span class="params">(Input source)</span>&#123;</span><br><span class="line">        <span class="type">TokenList</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenList</span>();</span><br><span class="line">        <span class="keyword">while</span>(!source.reachEndFile())&#123;</span><br><span class="line">            source.skipBlacks();</span><br><span class="line">            <span class="comment">// 按行注释</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;//&quot;</span>.equals((source.getFollowingChars(<span class="number">2</span>))))&#123;</span><br><span class="line">                source.nextLine();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 成段注释</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;/*&quot;</span>.equals((source.getFollowingChars(<span class="number">2</span>))))&#123;</span><br><span class="line">                source.goForward(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">while</span>(!<span class="string">&quot;*/&quot;</span>.equals(source.getFollowingChars(<span class="number">2</span>))&amp;&amp;!source.reachEndFile())&#123;</span><br><span class="line">                    source.goForward(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;*/&quot;</span>.equals((source.getFollowingChars(<span class="number">2</span>))))&#123;</span><br><span class="line">                    source.goForward(<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(Token.Type type: Token.Type.values())&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> source.match(type.getPattern());</span><br><span class="line">                    <span class="keyword">if</span>(Objects.nonNull(token))&#123;</span><br><span class="line">                        <span class="type">Token</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Token</span>(type, source.getCurrentLineNumber(), token);</span><br><span class="line">                        tokens.append(temp);</span><br><span class="line">                        source.goForward(token.length());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tokens.print();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="各类符号正则匹配"><a href="#各类符号正则匹配" class="headerlink" title="各类符号正则匹配"></a>各类符号正则匹配</h2><p>对于各类符号来说，难点如下：</p><ul><li><p>注意顺序</p><ul><li><code>int</code>、<code>const</code>等保留字要在<code>Ident</code>前面</li><li><code>==</code>要在<code>=</code>前面。</li></ul></li><li><p>注意转义（个人建议是不确定的都转了就完事了）</p><ul><li><code>OR(&quot;\\|\\|&quot;),</code></li><li><code>MULT(&quot;\\*&quot;),</code></li><li><code>PLUS(&quot;\\+&quot;),</code></li><li><code>LPARENT(&quot;\\(&quot;),</code></li><li><code>LBRACK(&quot;\\[&quot;),</code></li><li><code>LBRACE(&quot;\\&#123;&quot;),</code></li></ul></li><li>注意分词<ul><li><code>int</code>、<code>const</code>等保留字匹配时后面需要加上<code>\\b</code>。</li><li>也可以使用前瞻断言<code>?!\\w</code>。</li></ul></li></ul><p>Type枚举类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span>&#123;</span><br><span class="line">        <span class="comment">//需要进行分词</span></span><br><span class="line">        MAINTK(<span class="string">&quot;main&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        CONSTTK(<span class="string">&quot;const&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        INTTK(<span class="string">&quot;int&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        BREAKTK(<span class="string">&quot;break&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        CONTINUETK(<span class="string">&quot;continue&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        IFTK(<span class="string">&quot;if&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        ELSETK(<span class="string">&quot;else&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        WHILETK(<span class="string">&quot;while&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        GETINTTK(<span class="string">&quot;getint&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        PRINTFTK(<span class="string">&quot;printf&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        RETURNTK(<span class="string">&quot;return&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        VOIDTK(<span class="string">&quot;void&quot;</span>,<span class="literal">true</span>),</span><br><span class="line">        <span class="comment">// 三个较为特殊的正则</span></span><br><span class="line">        IDENFR(<span class="string">&quot;[_A-Za-z][_A-Za-z0-9]*&quot;</span>),</span><br><span class="line">        INTCON(<span class="string">&quot;[0-9]+&quot;</span>),</span><br><span class="line">        STRCON(<span class="string">&quot;\\\&quot;[^\\\&quot;]*\\\&quot;&quot;</span>),</span><br><span class="line">        <span class="comment">// 涉及到 = 的双符号放在前面</span></span><br><span class="line">        LEQ(<span class="string">&quot;&lt;=&quot;</span>),</span><br><span class="line">        GEQ(<span class="string">&quot;&gt;=&quot;</span>),</span><br><span class="line">        EQL(<span class="string">&quot;==&quot;</span>),</span><br><span class="line">        NEQ(<span class="string">&quot;!=&quot;</span>),</span><br><span class="line">        <span class="comment">// 其他正常正则</span></span><br><span class="line">        NOT(<span class="string">&quot;!&quot;</span>),</span><br><span class="line">        AND(<span class="string">&quot;&amp;&amp;&quot;</span>),</span><br><span class="line">        OR(<span class="string">&quot;\\|\\|&quot;</span>),</span><br><span class="line">        PLUS(<span class="string">&quot;\\+&quot;</span>),</span><br><span class="line">        MINU(<span class="string">&quot;-&quot;</span>),</span><br><span class="line">        MULT(<span class="string">&quot;\\*&quot;</span>),</span><br><span class="line">        DIV(<span class="string">&quot;/&quot;</span>),</span><br><span class="line">        MOD(<span class="string">&quot;%&quot;</span>),</span><br><span class="line">        LSS(<span class="string">&quot;&lt;&quot;</span>),</span><br><span class="line">        GRE(<span class="string">&quot;&gt;&quot;</span>),</span><br><span class="line">        ASSIGN(<span class="string">&quot;=&quot;</span>),</span><br><span class="line">        SEMICN(<span class="string">&quot;;&quot;</span>),</span><br><span class="line">        COMMA(<span class="string">&quot;,&quot;</span>),</span><br><span class="line">        LPARENT(<span class="string">&quot;\\(&quot;</span>),</span><br><span class="line">        RPARENT(<span class="string">&quot;\\)&quot;</span>),</span><br><span class="line">        LBRACK(<span class="string">&quot;\\[&quot;</span>),</span><br><span class="line">        RBRACK(<span class="string">&quot;\\]&quot;</span>),</span><br><span class="line">        LBRACE(<span class="string">&quot;\\&#123;&quot;</span>),</span><br><span class="line">        RBRACE(<span class="string">&quot;\\&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">        Type(String name)&#123;</span><br><span class="line">            <span class="built_in">this</span>.pattern = Pattern.compile(<span class="string">&quot;^&quot;</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">        Type(String name,<span class="type">boolean</span> br)&#123;</span><br><span class="line">            <span class="keyword">if</span>(br==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.pattern = Pattern.compile(<span class="string">&quot;^&quot;</span>+name+<span class="string">&quot;\\b&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Pattern <span class="title function_">getPattern</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pattern;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/posts/a95e.html"/>
      <url>/posts/a95e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在写编译的时候发现在词法分析环节可以使用正则表达式来简化分析过程，故先对正则表达式进行学习。由于平时写的最多的还是JS，所以先从JS的正则入手，然后再分析Java和JS中正则的异同。</p></blockquote><h1 id="JS正则表达式"><a href="#JS正则表达式" class="headerlink" title="JS正则表达式"></a>JS正则表达式</h1><h2 id="模式和修饰符"><a href="#模式和修饰符" class="headerlink" title="模式和修饰符"></a>模式和修饰符</h2><p>在JavaScript中我们有两种创建正则表达式对象的语法：</p><p>较长一点的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regexp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;pattern&quot;</span>, <span class="string">&quot;flags&quot;</span>);</span><br></pre></td></tr></table></figure><p>较短一点的语法，使用斜线 <code>&quot;/&quot;</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regexp = <span class="regexp">/pattern/</span>; <span class="comment">// 没有修饰符</span></span><br><span class="line">regexp = <span class="regexp">/pattern/gmi</span>; <span class="comment">// 带有修饰符 g、m 和 i</span></span><br></pre></td></tr></table></figure><p>这两种语法之间的主要区别在于，使用斜线 <code>/.../</code> 的模式不允许插入表达式（如带有 <code>$&#123;...&#125;</code> 的字符串模板）。它是完全静态的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tag = <span class="title function_">prompt</span>(<span class="string">&quot;What tag do you want to find?&quot;</span>, <span class="string">&quot;h2&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`&lt;<span class="subst">$&#123;tag&#125;</span>&gt;`</span>);</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在 JavaScript 中，有 6 个修饰符：</p><ul><li><p><code>i</code></p><p>使用此修饰符后，搜索时不区分大小写。</p></li><li><p><code>g</code></p><p>使用此修饰符后，搜索时会寻找所有的匹配项 —— 没有它，则仅返回第一个匹配项。</p></li><li><p><code>m</code></p><p>多行模式。</p></li><li><p><code>s</code></p><p>启用 “dotall” 模式，允许点 <code>.</code> 匹配换行符 <code>\n</code>。</p></li><li><p><code>u</code></p><p>开启完整的 Unicode 支持。</p></li><li><p><code>y</code></p><p>粘滞模式，在文本中的确切位置搜索。</p></li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p><code>str.match(regexp)</code> 方法在字符串 <code>str</code> 中寻找 <code>regexp</code> 的所有匹配项。</p><p>如果有修饰符<code>g</code>，则返回一个由所有匹配项构成的数组；如果没有这样的修饰符，则会以<strong>数组形式</strong>返回第一个匹配项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;We will, we will rock you&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = str.<span class="title function_">match</span>(<span class="regexp">/we/i</span>); <span class="comment">// 没有修饰符 g</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( result[<span class="number">0</span>] );     <span class="comment">// We（第一个匹配项）</span></span><br><span class="line"><span class="title function_">alert</span>( result.<span class="property">length</span> ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>如果没有匹配组，则返回<code>null</code>。</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>str.replace(regexp, replacement)</code> 方法使用 <code>replacement</code> 替换在字符串 <code>str</code> 中找到的 <code>regexp</code> 的匹配项（如果带有修饰符 <code>g</code> 则替换所有匹配项，否则只替换第一个）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有修饰符 g</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;We will, we will&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/we/i</span>, <span class="string">&quot;I&quot;</span>) ); <span class="comment">// I will, we will</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有修饰符 g</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;We will, we will&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/we/ig</span>, <span class="string">&quot;I&quot;</span>) ); <span class="comment">// I will, I will</span></span><br></pre></td></tr></table></figure><p>对于第二个参数 <code>replacement</code> ，可以在其中使用特殊字符组合来对匹配项进行插入：</p><div class="table-container"><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">在替换字符串中的行为</th></tr></thead><tbody><tr><td style="text-align:left"><code>$&amp;</code></td><td style="text-align:left">插入整个匹配项</td></tr><tr><td style="text-align:left">$`</td><td style="text-align:left">插入字符串中匹配项之前的字符串部分</td></tr><tr><td style="text-align:left"><code>$&#39;</code></td><td style="text-align:left">插入字符串中匹配项之后的字符串部分</td></tr><tr><td style="text-align:left"><code>$n</code></td><td style="text-align:left">如果 <code>n</code> 是一个 1-2 位的数字，则插入第 n 个分组的内容</td></tr><tr><td style="text-align:left"><code>$&lt;name&gt;</code></td><td style="text-align:left">插入带有给定 <code>name</code> 的括号内的内容</td></tr><tr><td style="text-align:left">$$$$</td><td style="text-align:left">插入字符 <code>$</code></td></tr></tbody></table></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;I love HTML&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/HTML/</span>, <span class="string">&quot;$&amp; and JavaScript&quot;</span>) ); <span class="comment">// I love HTML and JavaScript</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;I love HTML&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/HTML/</span>, <span class="string">&quot;$` and JavaScript&quot;</span>) ); <span class="comment">// I love I love  and JavaScript</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;I love HTML&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/HTML/</span>, <span class="string">&quot;$&#x27; and JavaScript&quot;</span>) ); <span class="comment">//I love I love  and JavaScript</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><code>regexp.test(str)</code> 方法寻找至少一个匹配项，如果找到了，则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;I love JavaScript&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/LOVE/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( regexp.<span class="title function_">test</span>(str) ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p><strong>字符类（Character classes）</strong> 是一种特殊的符号，匹配特定集合中的任何符号。</p><p>最常用的是：</p><ul><li><p><code>\d</code>（“d” 来自 “digit”）</p><p>数字：从 <code>0</code> 到 <code>9</code> 的字符。</p></li><li><p><code>\s</code>（“s” 来自 “space”）</p><p>空格符号：包括空格，制表符 <code>\t</code>，换行符 <code>\n</code> 和其他少数稀有字符，例如 <code>\v</code>、<code>\f</code> 和 <code>\r</code>。</p></li><li><p><code>\w</code>（“w” 来自 “word”）</p></li></ul><p>“单字”字符：拉丁字母或数字或下划线 <code>_</code>。非拉丁字母不属于 <code>\w</code>。</p><p>例如，<code>\d\s\w</code> 表示“数字”，后跟“空格字符”，后跟“单字字符”，例如 <code>1 a</code>。</p><p>对于每个字符类，都有一个“反向类”，用相同的字母表示，但是大写的。</p><p>“反向”表示它与所有其他字符匹配，例如：</p><ul><li><p><code>\D</code></p><p>非数字：除 <code>\d</code> 以外的任何字符，例如字母。</p></li><li><p><code>\S</code></p><p>非空格符号：除 <code>\s</code> 以外的任何字符，例如字母。</p></li><li><p><code>\W</code></p><p>非单字字符：除 <code>\w</code> 以外的任何字符，例如非拉丁字母或空格。</p></li></ul><p>从 <code>+7(903)-123-45-67</code> 这样的字符串中创建一个只包含数字的电话号码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;+7(903)-123-45-67&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d/g</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) ); <span class="comment">// 79031234567</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">replace</span>(<span class="regexp">/\D/g</span>, <span class="string">&quot;&quot;</span>) ); <span class="comment">// 79031234567</span></span><br></pre></td></tr></table></figure><h3 id="匹配任意字符的"><a href="#匹配任意字符的" class="headerlink" title="匹配任意字符的."></a>匹配任意字符的<code>.</code></h3><p>点 <code>.</code> 是一种特殊字符类，它与“除换行符之外的任何字符”匹配。点不是缺少字符，我们必须有一个字符和点匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/CS.4/</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;CSS4&quot;</span>.<span class="title function_">match</span>(regexp) ); <span class="comment">// CSS4</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;CS-4&quot;</span>.<span class="title function_">match</span>(regexp) ); <span class="comment">// CS-4</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;CS 4&quot;</span>.<span class="title function_">match</span>(regexp) ); <span class="comment">// CS 4（空格也是一个字符）</span></span><br></pre></td></tr></table></figure><p>之前提到过<code>s</code>的作用是启用 “dotall” 模式，允许点 <code>.</code> 匹配换行符 <code>\n</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;A\nB&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/A.B/</span>s) ); <span class="comment">// A\nB（匹配了！）</span></span><br></pre></td></tr></table></figure><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>插入符号 <code>^</code> 和美元符号 <script type="math/tex">` 在正则表达式中具有特殊的含义。它们被称为“锚点”。（这里的`</script>和replace()中的<code>$</code>作用不同。）</p><p>插入符号 <code>^</code> 匹配文本开头，而 <script type="math/tex">` 则匹配文本末尾。两个锚点 `^...</script> 放在一起通常被用于测试一个字符串是否完全匹配一个模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;Mary had a little lamb&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>( <span class="regexp">/^Mary/</span>.<span class="title function_">test</span>(str1) ); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;it&#x27;s fleece was white as snow&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>( <span class="regexp">/snow$/</span>.<span class="title function_">test</span>(str1) ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="多行模式"><a href="#多行模式" class="headerlink" title="多行模式"></a>多行模式</h3><p>锚点的多行模式由修饰符<code>m</code>启用。</p><p>它只影响<code>^</code>和<code>$</code>的行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`1st place: Winnie</span></span><br><span class="line"><span class="string">2nd place: Piglet</span></span><br><span class="line"><span class="string">3rd place: Eeyore`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">match</span>(<span class="regexp">/^\d/gm</span>) ); <span class="comment">// 1, 2, 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">match</span>(<span class="regexp">/^\d/g</span>) ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`Winnie: 1</span></span><br><span class="line"><span class="string">Piglet: 2</span></span><br><span class="line"><span class="string">Eeyore: 3`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d\n/g</span>) ); <span class="comment">// 1\n,2\n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d$/gm</span>) ); <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><h3 id="词边界"><a href="#词边界" class="headerlink" title="词边界"></a>词边界</h3><p>词边界 <code>\b</code> 是一种检查，就像 <code>^</code> 和 <code>$</code> 一样。</p><p>有三种不同的位置可作为词边界：</p><ul><li>在字符串开头，如果第一个字符是单词字符 <code>\w</code>。</li><li>在字符串中的两个字符之间，其中一个是单词字符 <code>\w</code>，另一个不是。</li><li>在字符串末尾，如果最后一个字符是单词字符 <code>\w</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Hello, Java!&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\bHello\b/</span>) ); <span class="comment">// Hello</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Hello, Java!&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\bJava\b/</span>) );  <span class="comment">// Java</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Hello, Java!&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\bHell\b/</span>) );  <span class="comment">// null（无匹配项）</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Hello, Java!&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\bJava!\b/</span>) ); <span class="comment">// null（无匹配项）</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;1 23 456 78&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\b\d\d\b/g</span>) ); <span class="comment">// 23,78</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;12,34,56&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\b\d\d\b/g</span>) ); <span class="comment">// 12,34,56</span></span><br></pre></td></tr></table></figure><h2 id="转义与特殊字符"><a href="#转义与特殊字符" class="headerlink" title="转义与特殊字符"></a>转义与特殊字符</h2><ul><li>要在字面意义上搜索特殊字符 <code>[ \ ^ $ . | ? * + ( )</code>，我们需要在它们前面加上一个反斜杠 <code>\</code>（“转义它们”）。</li><li>如果在 <code>/.../</code> 内（但不在 <code>new RegExp</code> 内），我们还需要转义 <code>/</code>。</li><li>当将字符串传递给给 <code>new RegExp</code> 时，我们需要双反斜杠 <code>\\</code>，因为字符串引号会消耗一个反斜杠。</li></ul><h2 id="集合与范围"><a href="#集合与范围" class="headerlink" title="集合与范围"></a>集合与范围</h2><p>在方括号 <code>[…]</code> 中的几个字符或者字符类表示“搜索给定字符中的任意一个”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找 [t 或 m]，然后匹配 &quot;op&quot;</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Mop top&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/[tm]op/gi</span>) ); <span class="comment">// &quot;Mop&quot;, &quot;top&quot;</span></span><br><span class="line"><span class="comment">// 查找 &quot;V&quot;，然后匹配 [o 或 i]，之后匹配 &quot;la&quot;</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Voila&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/V[oi]la/</span>) ); <span class="comment">// null，无匹配项</span></span><br></pre></td></tr></table></figure><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>方括号也可以包含字符范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;Exception 0xAF&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/x[0-9A-F][0-9A-F]/g</span>) ); <span class="comment">// xAF</span></span><br></pre></td></tr></table></figure><p>如果我们还想查找小写字母，则可以添加范围 <code>a-f</code>：<code>[0-9A-Fa-f]</code>。或添加标志 <code>i</code>。</p><p>我们也可以在 <code>[…]</code> 中使用字符类。</p><p>例如，如果我们想查找单词字符 <code>\w</code> 或连字符 <code>-</code>，则集合可以写为 <code>[\w-]</code>。</p><p>字符类其实是某些字符集合的缩写，例如：</p><ul><li><strong>\d</strong> —— 和 <code>[0-9]</code> 相同，</li><li><strong>\w</strong> —— 和 <code>[a-zA-Z0-9_]</code> 相同，</li><li><strong>\s</strong> —— 和 <code>[\t\n\v\f\r ]</code> 外加少量罕见的 Unicode 空格字符相同。</li></ul><h3 id="排除范围"><a href="#排除范围" class="headerlink" title="排除范围"></a>排除范围</h3><p>除了普通的范围匹配，还有像这样 <code>[^…]</code> 的“排除”范围匹配。</p><p>通过在开头添加插入符号 <code>^</code> 来表示匹配所有 <strong>除了给定的字符</strong> 之外的任意字符。</p><p>例如：</p><ul><li><code>[^aeyo]</code> —— 匹配除了 <code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;y&#39;</code> 或 <code>&#39;o&#39;</code> 之外的任何字符。</li><li><code>[^0-9]</code> —— 匹配除了数字之外的任何字符，与 <code>\D</code> 作用相同。</li><li><code>[^\s]</code> —— 匹配任何非空格字符，与 <code>\S</code> 作用相同。</li></ul><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><h3 id="n"><a href="#n" class="headerlink" title="{n}"></a>{n}</h3><p>在字符、字符类或集合后附加一个<code>&#123;n&#125;</code>，用来指出我们具体需要的数量。</p><p><code>\d&#123;5&#125;</code> 表示 5 位数，与 <code>\d\d\d\d\d</code> 相同。</p><p><strong>范围：</strong><code>&#123;3,5&#125;</code>，匹配 3-5 个</p><p>我们可以省略上限，那么正则表达式 <code>\d&#123;3,&#125;</code> 就会查找位数大于等于 <code>3</code> 的数字：</p><p>我们如果需要一个及以上的数字，就使用 <code>\d&#123;1,&#125;</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;+7(903)-123-45-67&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = str.<span class="title function_">match</span>(<span class="regexp">/\d&#123;1,&#125;/g</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(numbers); <span class="comment">// 7,903,123,45,67</span></span><br></pre></td></tr></table></figure><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p>大多数常用量词都有缩写形式。（缩写都是针对前面的字符）</p><h4 id=""><a href="#" class="headerlink" title="+"></a><code>+</code></h4><p>代表一个或多个，与<code>&#123;1,&#125;</code>相同。</p><p>例如，<code>\d+</code> 用来查找所有数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;+7(903)-123-45-67&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d+/g</span>) ); <span class="comment">// 7,903,123,45,67</span></span><br></pre></td></tr></table></figure><h4 id="-1"><a href="#-1" class="headerlink" title="?"></a><code>?</code></h4><p>代表一个或零个，与<code>&#123;0,1&#125;</code>相同。</p><p>所以 <code>colou?r</code> 会找到 <code>color</code> 和 <code>colour</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Should I write color or colour?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/colou?r/g</span>) ); <span class="comment">// color, colour</span></span><br></pre></td></tr></table></figure><h4 id="-2"><a href="#-2" class="headerlink" title="*"></a><code>*</code></h4><p>代表“零个及以上”，与 <code>&#123;0,&#125;</code> 相同。</p><p>例如，<code>\d0*</code> 查找一个数字后面跟着任意数量的零（可能有很多或没有）的数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;100 10 1&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\d0*/g</span>) ); <span class="comment">// 100, 10, 1</span></span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>量词是构成复杂正则表达式的主要“模块”。</p><ul><li>小数：<code>\d+\.\d+</code></li><li>HTML标签：<code>/&lt;[a-z]+&gt;/i</code> <code>/&lt;[a-z][a-z0-9]*&gt;/i</code> <code>/&lt;\/?[a-z][a-z0-9]\*&gt;/i</code></li><li>“…”(任意三个字符)：<code>/\.&#123;3,&#125;/g</code></li><li><code>#</code>开头的颜色值：<code>/#[0-9a-f]&#123;6&#125;\b/gi</code></li></ul><h2 id="贪婪量词与惰性量词"><a href="#贪婪量词与惰性量词" class="headerlink" title="贪婪量词与惰性量词"></a>贪婪量词与惰性量词</h2><p>量词功能十分强大，但也会产生一些让人困惑的问题。</p><p>比如说有一个文本，我们需要用书名号：<code>«...»</code> 来代替所有的引号 <code>&quot;...&quot;</code>。</p><p>首先想到的写法是使用<code>.+</code>匹配<code>&quot;</code>中的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/&quot;.+&quot;/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;a &quot;witch&quot; and her &quot;broom&quot; is one&#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(regexp) ); <span class="comment">// &quot;witch&quot; and her &quot;broom&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到预期结果与想象中的不同。这是因为正则在查找时采用了贪婪算法。</p><ol><li><p>该模式的第一个字符是一个引号 <code>&quot;</code>。</p><p>正则表达式引擎尝试在源字符串 <code>a &quot;witch&quot; and her &quot;broom&quot; is one</code> 的位置 0 找到它，但那里有 <code>a</code>，所以匹配失败。</p><p>然后继续前进：移至源字符串中的下一个位置，并尝试匹配模式中的第一个字符，再次失败，最终在第三个位置匹配到了引号：</p><p>a ==”==witch” and her “broom” is one</p></li><li><p>找到引号后，引擎就尝试去匹配模式中的剩余字符。它尝试查看剩余的字符串是否符合 <code>.+&quot;</code>。</p><p>在我们的用例中，模式中的下一个字符为 <code>.</code>（一个点）。它表示匹配除了换行符之外的任意字符，所以将会匹配下一个字符 <code>&#39;w&#39;</code>：</p><p>a ==”w==itch” and her “broom” is one</p></li><li><p>然后由于量词 <code>.+</code>，点会重复。正则表达式引擎一个接一个字符地进行匹配。</p><p>……什么时候会不匹配？点（.）能够匹配所有字符，所以只有在移至字符串末尾时才停止匹配：</p><p>a ==”witch” and her “broom” is one==</p></li><li><p>现在引擎完成了对重复模式 <code>.+</code> 的搜索，并且试图寻找模式中的下一个字符。是引号 <code>&quot;</code>。但是有一个问题：对字符串的遍历已经结束，没有更多字符了！</p><p>正则表达式引擎知道它为 <code>.+</code> 匹配太多项了，所以开始 <strong>回溯</strong>。</p><p>换句话说，它去掉了量词匹配项的最后一个字符：</p><p>a ==”witch” and her “broom” is on==e</p><p>现在它假设 <code>.+</code> 的匹配在字符串的倒数第一个字符前的位置结束，并尝试从该位置匹配模式的剩余部分。</p><p>如果那里有引号，则搜索将结束，但最后一个字符是 <code>&#39;e&#39;</code>，所以不匹配。</p></li><li><p>……所以引擎会将 <code>.+</code> 的重复次数减少一个字符：</p><p>引号 <code>&#39;&quot;&#39;</code> 与 <code>&#39;n&#39;</code> 不匹配。</p></li><li><p>引擎不断进行回溯：它减少 <code>&#39;.&#39;</code> 的重复次数，直到模式的其余部分（在我们的用例中是 <code>&#39;&quot;&#39;</code>）匹配到结果：</p></li></ol><p>​        a ==”witch” and her “broom”== is one 匹配完成。</p><p>所以，第一次匹配项是 <code>&quot;witch&quot; and her &quot;broom&quot;</code>。如果正则表达式具有修饰符 <code>g</code>，则搜索将从第一个匹配结束的地方继续。字符串 <code>is one</code> 的剩余部分不再有引号，因此没有更多匹配项。</p><h3 id="惰性模式"><a href="#惰性模式" class="headerlink" title="惰性模式"></a>惰性模式</h3><p>我们可以通过在量词后面加一个<code>?</code>来启用惰性模式，这样搜索过程将转变为：</p><ol><li><p>第一步是一样的：它在第三个字符的位置找到了模式的开头 <code>&#39;&quot;&#39;</code>： a ==”==witch” and her “broom” is one</p></li><li><p>下一步也是类似的：引擎为 <code>&#39;.&#39;</code> 找到了一个匹配项： a ==”w==itch” and her “broom” is one</p></li><li><p>接下来的搜索就有些不同了。因为我们对 <code>+?</code> 启用了惰性模式，引擎不会去尝试多匹配一个点的匹配字符，而会停止并<strong>立即尝试对剩余的模式 <code>&#39;&quot;&#39;</code> 进行匹配</strong>： a ==”w==itch” and her “broom” is one</p><p>如果这里有一个引号，搜索就会停止，但这里是一个 <code>&#39;i&#39;</code>，所以没有匹配到引号。</p></li><li><p>接着，正则表达式引擎增加对点的重复搜索次数，并且再次尝试： a ==”wi==tch” and her “broom” is one</p><p>又失败了。然后重复次数一次又一次的增加……</p></li><li><p>……直到找到了模式中的剩余部分的匹配项： a ==”witch”== and her “broom” is one</p></li><li><p>接下来的搜索从当前匹配的结尾开始，并产生了下一个匹配项： a ==”witch”== and her ==”broom”== is one</p></li></ol><p>在这个例子中，我们看到了惰性模式的 <code>+?</code> 是怎样工作的。量词 <code>*?</code> 和 <code>??</code> 的工作方式类似 —— 正则表达式引擎仅在模式的其余部分无法在给定位置匹配时增加重复次数。</p><p>另一个惰性模式的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;123 456&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\d+ \d+?/</span>) ); <span class="comment">// 123 4</span></span><br></pre></td></tr></table></figure><h3 id="替代方法"><a href="#替代方法" class="headerlink" title="替代方法"></a>替代方法</h3><p>上面这个例子还有一个替代的正则表达式：<code>/&quot;[^&quot;]+&quot;/g</code></p><h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><p>模式的一部分可以使用<code>()</code>括起来，这被称为捕获组(capturing group)，捕获组有两个影响：</p><ul><li>它允许将匹配的一部分作为结果数组中的单独项。</li><li>如果我们将量词放在括号后，则它将括号视为一个整体。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="gogogo"><a href="#gogogo" class="headerlink" title="gogogo"></a><code>gogogo</code></h4><p>不带括号，模式 <code>go+</code> 表示 <code>g</code> 字符，其后 <code>o</code> 重复一次或多次。例如 <code>goooo</code> 或 <code>gooooooooo</code>。</p><p>括号将字符组合，所以 <code>(go)+</code> 匹配 <code>go</code>，<code>gogo</code>，<code>gogogo</code>等。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mail.com</span><br><span class="line">users.mail.com</span><br><span class="line">smith.users.mail.com</span><br></pre></td></tr></table></figure><p>域名是由单词加点组成的，除了最后一个单词</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(\w+\.)+\w+/g</span>;</span><br></pre></td></tr></table></figure><h4 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h4><p>电子邮件的格式为<code>name@domain</code>。名称可以是任何单词，允许使用连字符和点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/[-.\w]+@([\w-]+\.)+[\w-]+/g</span>;</span><br></pre></td></tr></table></figure><p>这里<code>[]</code>中的<code>.</code>可以不用转义，但<code>()</code>中的<code>.</code>需要转义。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>方括号只允许字符或字符类。选择允许任何表达式。正则表达式 <code>A|B|C</code> 表示表达式 <code>A</code>、<code>B</code> 或 <code>C</code> 其一均可。</p><p>例如：</p><ul><li><code>gr(a|e)y</code> 等同于 <code>gr[ae]y</code>。</li><li><code>gra|ey</code> 表示 <code>gra</code> 或 <code>ey</code>。</li></ul><p>要将选择应用于模式中一部分内容的选择，我们可以将其括在括号中：</p><ul><li><code>I love HTML|CSS</code> 匹配 <code>I love HTML</code> 或 <code>CSS</code>。</li><li><code>I love (HTML|CSS)</code> 匹配 <code>I love HTML</code> 或 <code>I love CSS</code>。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>时间匹配的正则表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/([01]\d|2[0-3]):[0-5]\d/g</span>;</span><br></pre></td></tr></table></figure><h2 id="前瞻断言与后瞻断言"><a href="#前瞻断言与后瞻断言" class="headerlink" title="前瞻断言与后瞻断言"></a>前瞻断言与后瞻断言</h2><p>有时我们需要为一个模式找到那些在另一个模式之后或之前的匹配项。</p><h3 id="前瞻断言"><a href="#前瞻断言" class="headerlink" title="前瞻断言"></a>前瞻断言</h3><p>语法为：<code>x(?=y)</code>，它表示“仅在后面是 <code>Y</code> 时匹配 <code>X</code>”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1 turkey costs 30€&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d+(?=€)/</span>) ); <span class="comment">// 30，数字 1 被忽略了，因为它后面没有 €</span></span><br></pre></td></tr></table></figure><p><code>\d+(?=\s)(?=.*30)</code> 查找后跟着空格 <code>(?=\s)</code> 的 <code>\d+</code>，并且有 <code>30</code> 在它之后的某个地方 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1 turkey costs 30€&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d+(?=\s)(?=.*30)/</span>) ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="否定前瞻断言"><a href="#否定前瞻断言" class="headerlink" title="否定前瞻断言"></a>否定前瞻断言</h3><p>语法是：<code>X(?!Y)</code>，意思是“搜索 <code>X</code>，但前提是后面没有 <code>Y</code>”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;2 turkeys cost 60€&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/\d+\b(?!€)/g</span>) ); <span class="comment">// 2（价格不匹配）</span></span><br></pre></td></tr></table></figure><h3 id="后瞻断言"><a href="#后瞻断言" class="headerlink" title="后瞻断言"></a>后瞻断言</h3><p>前瞻断言允许添加一个“后面要跟着什么”的条件判断。</p><p>后瞻断言也类似，只不过它是在相反的方向上进行条件判断。也就是说，它只允许匹配前面有特定字符串的模式。</p><p>语法为如下：</p><ul><li>肯定的后瞻断言：<code>(?&lt;=Y)X</code>，匹配 <code>X</code>，仅在前面是 <code>Y</code> 的情况下。</li><li>否定的后瞻断言：<code>(?&lt;!Y)X</code>，匹配 <code>X</code>，仅在前面不是 <code>Y</code> 的情况下。</li></ul><p>使用 <code>(?&lt;=\$)\d+</code> —— 一个前面带 <code>$</code> 的数值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1 turkey costs $30&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 美元符号被转义 \$</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/(?&lt;=\$)\d+/</span>) ); <span class="comment">// 30（跳过了仅仅是数字的值）</span></span><br></pre></td></tr></table></figure><p>我们可以使用否定的后瞻断言：<code>(?&lt;!\$)\d+</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;2 turkeys cost $60&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">match</span>(<span class="regexp">/(?&lt;!\$)\b\d+/g</span>) ); <span class="comment">// 2（价格不匹配）</span></span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>选择非负整数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/\b(?&lt;!-)\d+\b/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;0 12 -5 123 -18&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">match</span>(regexp) ); <span class="comment">// 0, 12, 123</span></span><br></pre></td></tr></table></figure><h1 id="Java正则"><a href="#Java正则" class="headerlink" title="Java正则"></a>Java正则</h1><p>对Java正则来说，主要包括以下三个类：</p><ul><li><p>Pattern 类：</p><p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p></li><li><p>Matcher 类：</p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p></li><li><p>PatternSyntaxException：</p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexMatches</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 按指定模式在字符串查找</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;This order was placed for QT3000! OK?&quot;</span>;</span><br><span class="line">      <span class="comment">// 找一个包含数字的字符串</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;(\\D*)(\\d+)(.*)&quot;</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 创建 Pattern 对象</span></span><br><span class="line">      <span class="type">Pattern</span> <span class="variable">r</span> <span class="operator">=</span> Pattern.compile(pattern);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 现在创建 matcher 对象</span></span><br><span class="line">      <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> r.matcher(line);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，<code>\\</code>表示我要插入一个具有特殊意义的正则表达式的反斜线，而在JS等很多其他语言中，<code>\</code>就能达到相同的效果。</p><p>下面是Matcher类的一些方法：</p><h2 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h2><p>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>序号</strong></th><th style="text-align:left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public int start()</strong> 返回以前匹配的初始索引。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public int start(int group)</strong>  返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public int end()</strong> 返回最后匹配字符之后的偏移量。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public int end(int group)</strong> 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td></tr></tbody></table></div><h2 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h2><p>查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>序号</strong></th><th style="text-align:left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public boolean lookingAt()</strong>  尝试将从区域开头开始的输入序列与该模式匹配。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public boolean find()</strong> 尝试查找与该模式匹配的输入序列的下一个子序列。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public boolean find(int start**</strong>）** 重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public boolean matches()</strong> 尝试将整个区域与模式匹配。</td></tr></tbody></table></div><h2 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h2><p>替换方法是替换输入字符串里文本的方法：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>序号</strong></th><th style="text-align:left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public Matcher appendReplacement(StringBuffer sb, String replacement)</strong> 实现非终端添加和替换步骤。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public StringBuffer appendTail(StringBuffer sb)</strong> 实现终端添加和替换步骤。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public String replaceAll(String replacement)</strong>  替换模式与给定替换字符串相匹配的输入序列的每个子序列。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public String replaceFirst(String replacement)</strong>  替换模式与给定替换字符串匹配的输入序列的第一个子序列。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>public static String quoteReplacement(String s)</strong> 返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"平畴的博客","short_name":"平畴的博客","theme_color":"#49b1f5","background_color":"#49b1f5","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: 'ZhuZiAYuanJWD';  }  h1#site-title {    /* font-family: ZhuZiAYuanJWD; */    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: 'iconfont' !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  .bangumi-active {    background: #dbecfe !important;    border-radius: 10px !important;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: #dbecfe !important;    border-radius: 10px !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme='dark'] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme='dark'] .card-widget {    background: #121212 !important;  }    [data-theme='dark'] div#post {    background: #121212 !important;  }    [data-theme='dark'] div#tag {    background: #121212 !important;  }    [data-theme='dark'] div#archive {    background: #121212 !important;  }    [data-theme='dark'] div#page {    background: #121212 !important;  }    [data-theme='dark'] div#category {    background: #121212 !important;  }    [data-theme='dark'] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }    #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #49b1f5;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #49b1f5;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* 鼠标图标 */  body {    cursor: url('/img/x1.cur'), auto;  }  a,  [type='button']:not(:disabled),  [type='reset']:not(:disabled),  [type='submit']:not(:disabled),  button:not(:disabled) {    cursor: url('/img/x2.cur'), auto !important;  }  /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #49b1f5;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft JhengHei', 'Microsoft YaHei', sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--heo-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }  ]]></content>
      
    </entry>
    
    
  
</search>
